% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cellassign.R
\name{cellassign}
\alias{cellassign}
\title{Annotate cells to cell types using cellassign}
\usage{
cellassign(
  exprs_obj,
  marker_gene_info,
  s = NULL,
  min_delta = 2,
  X = NULL,
  B = 10,
  shrinkage = TRUE,
  n_batches = 1,
  dirichlet_concentration = 0.01,
  rel_tol_adam = 1e-04,
  rel_tol_em = 1e-04,
  max_iter_adam = 1e+05,
  max_iter_em = 20,
  learning_rate = 0.1,
  verbose = TRUE,
  sce_assay = "counts",
  return_SCE = FALSE,
  num_runs = 1,
  threads = 0
)
}
\arguments{
\item{exprs_obj}{Either a matrix representing gene
expression counts or a \code{SummarizedExperiment}.
See details.}

\item{marker_gene_info}{Information relating marker genes to cell types.
See details.}

\item{s}{Numeric vector of cell size factors}

\item{min_delta}{The minimum log fold change a marker gene must
be over-expressed by in its cell type}

\item{X}{Numeric matrix of external covariates. See details.}

\item{B}{Number of bases to use for RBF dispersion function}

\item{shrinkage}{Logical - should the delta parameters
have hierarchical shrinkage?}

\item{n_batches}{Number of data subsample batches to use in inference}

\item{dirichlet_concentration}{Dirichlet concentration parameter for cell
type abundances}

\item{rel_tol_adam}{The change in Q function value (in pct) below which
each optimization round is considered converged}

\item{rel_tol_em}{The change in log marginal likelihood value (in pct)
below which the EM algorithm is considered converged}

\item{max_iter_adam}{Maximum number of ADAM iterations
to perform in each M-step}

\item{max_iter_em}{Maximum number of EM iterations to perform}

\item{learning_rate}{Learning rate of ADAM optimization}

\item{verbose}{Logical - should running info be printed?}

\item{sce_assay}{The \code{assay} from the input#' \code{SingleCellExperiment} to use: this assay
should always represent raw counts.}

\item{return_SCE}{Logical - should a SingleCellExperiment be returned
with the cell
type annotations added? See details.}

\item{num_runs}{Number of EM optimizations to perform (the one with the maximum
log-marginal likelihood value will be used as the final).}

\item{threads}{Maximum number of threads used by the algorithm
(defaults to the number of cores available on the machine)}
}
\value{
An object of class \code{cellassign}. See \code{details}
}
\description{
Automatically annotate cells to known types based
on the expression patterns of
a priori known marker genes.
}
\details{
\strong{Input format}
\code{exprs_obj} should be either a
\code{SummarizedExperiment} (we recommend the
\code{SingleCellExperiment} package) or a
cell (row) by gene (column) matrix of
\emph{raw} RNA-seq counts (do \strong{not}
log-transform or otherwise normalize).

\code{marker_gene_info} should either be
\itemize{
\item A gene by cell type binary matrix, where a 1 indicates that a gene is a
marker for a cell type, and 0 otherwise
\item A list with names corresponding to cell types, where each entry is a
vector of marker gene names. These are converted to the above matrix using
the \code{marker_list_to_mat} function.
}

\strong{Cell size factors}
If the cell size factors \code{s} are
not provided they are computed using the
\code{computeSumFactors} function from
the \code{scran} package.

\strong{Covariates}
If \code{X} is not \code{NULL} then it should be
an \code{N} by \code{P} matrix
of covariates for \code{N} cells and \code{P} covariates.
Such a matrix would typically
be returned by a call to \code{model.matrix}
\strong{with no intercept}. It is also highly
recommended that any numerical (ie non-factor or one-hot-encoded)
covariates be standardized
to have mean 0 and standard deviation 1.

\strong{cellassign}
A call to \code{cellassign} returns an object
of class \code{cellassign}. To access the
MLE estimates of cell types, call \code{fit$cell_type}.
To access all MLE parameter
estimates, call \code{fit$mle_params}.

\strong{Returning a SingleCellExperiment}

If \code{return_SCE} is true, a call to \code{cellassign} will return
the input SingleCellExperiment, with the following added:
\itemize{
\item A column \code{cellassign_celltype} to \code{colData(sce)} with the MAP
estimate of the cell type
\item A slot \code{sce@metadata$cellassign} containing the cellassign fit.
Note that a \code{SingleCellExperiment} must be provided as \code{exprs_obj}
for this option to be valid.
}
}
\examples{
data(example_sce)
data(example_marker_mat)

fit <- em_result <- cellassign(example_sce[rownames(example_marker_mat),],
marker_gene_info = example_marker_mat,
s = colSums(SummarizedExperiment::assay(example_sce, "counts")),
learning_rate = 1e-2,
shrinkage = TRUE,
verbose = FALSE)

}
